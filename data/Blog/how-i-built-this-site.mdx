---
title: What really powers my blog?
author: Swapnil Kumbhar
excerpt: MDX is magic and you should be using it.
category: Technology
subcategory: Web
slug: how-i-built-this
date: Thu Mar  3 11:51:07 AM MST 2022
---


# Overview

When I decided that I wanted my own space on the internet, I had two goals in mind with my setup. First, was ease (or convenience). Second, was freedom. The ability of incorporating different technologies without being tied down to one. [MDX](https://mdxjs.org) strikes this balance perfectly for me.

## Why MDX?

MDX expands upon [Markdown](https://en.wikipedia.org/wiki/Markdown) by giving the ability to use React components within Markdown. Markdown, to me, is an _extremely_ easy and fast format to write documentation. MDX strikes the balance perfectly; I can use my dynamic React components with the ease of Markdown. 

## How do I use MDX?

To do this, let's create a simple blog. Let's start with a basic TailwindCSS template. The best way to read this post is to have the code for this open in another tab or a text editor. Here's the [code](https://github.com/SwapnilKumbhar/mdxtemplate).

```sh
$ create-next-app --typescript --use-npm --example with-tailwindcss mdxtemplate
```

You can run this template using `npm run dev`. Keep this running in a terminal, as Next reflects every change immediately.

> This blog will assume some knowledge of NextJS, TailwindCSS and Typescript in the following section. Please refer to official documentation of these tools/frameworks for familiarity.

### Project structure

Upon running the command above, you will see a bunch of files and folders that are pretty standard for a NextJS project. In addition to these, we will create a few new files and folders. Here's a list - 

|Path|Type|Description
|---|---|---|
|./pages/posts/|Folder|Entrypoint for our blog under `/posts`|
|./pages/posts/index.tsx|File|File that will be rendered when we navigate to `/posts`|
|./pages/posts/[slug].tsx|File|Dynamic Route to any blogpost under `/posts`|
|./data/|Folder|Folder where we will store our raw `.mdx` blogs|
|./lib/blog.ts|File|Create a folder called `lib` and then a file called `blog.ts` within it|

Now, just to render our `mdx` files, we will need a few libraries. In a terminal with your project's folder open, run this command -

```
npm install @next/mdx next-mdx-remote gray-matter
```

We need the first two to render our blogs to HTML. We will use the last library to get custom metadata for each post. Every blog we write will have some metadata at the top enclosed within two `---`. This data is called `Frontmatter`. it has to be in valid YAML format for `gray-matter` to parse it. To get an idea of what you can have in this section, here's the Frontmatter for this post -

```
title: What really powers my blog?
author: Swapnil Kumbhar
excerpt: MDX is magic and you should be using it.
category: Technology
subcategory: Web
slug: how-i-built-this
date: Thu Mar  3 11:51:07 AM MST 2022
```

We will have something simpler like this -
```
title: Absolutely amazing MDX blogpost
author: Mark Down
slug: mdx-rules
```

### Loading MDX files

This is a relatively easy part of the entire process. In our `lib/blog.ts` file, we will create a few functions to read MDX files in the `./data/` directory. After reading these files, we will send them to `gray-matter` to get their metadata. Pretty simple. Here's how that looks -

```ts
import matter from 'gray-matter';
import fs from 'fs';
import path from 'path';

// The shape of the blog matter.
export interface FrontMatter {
  title: string
  author: string
  slug: string
}

// content is the raw blogpsot data without the metadata
export interface BlogPost {
  metadata: FrontMatter
  content: string
}

const MDX_DIR = './data/blog';

// All blog posts
const POSTS: BlogPost[] = [];

export async function loadMdx() {
  // Find names of every file in the folder that ends with `.mdx`
  // Then get their absolute paths by joining
  const blogEntries = fs.readdirSync(MDX_DIR)
    .filter((filename) => filename.endsWith('.mdx'))
    .map((filename) => path.join(MDX_DIR, filename));

  const blogData = blogEntries.map((file) => fs.readFileSync(file));

  // Add each blog to the global POSTS list
  blogData.forEach((file) => {
    const frontmatter = matter(file);
    POSTS.push({
      metadata: frontmatter.data as FrontMatter,
      content: frontmatter.content,
    });
  });
}

// Getter for all posts.
export const getAllPosts = async (): Promise<BlogPost[]> => {
  await loadMdx();
  return POSTS;
};

```

That's all we need for our backend! Now to the interesting part: The Frontend.

### Rendering MDX files

`next-mdx-remote` gives us a method called `serialize` that compiles raw MDX to HTML. This rendered HTML is passed to `<MDXRemote />`, a component in the library. 

> I'll be covering a few Nextjs specific details now. If you are not using Nextjs for this, you can skip the next two paragraphs.

To render a specific blog page, we are using Dynamic Routing. Since we are building a static blog, we can tell the routes that will exist on the blog ahead of time. This is where the `getStaticPaths()` function comes into picture. Let's say we have three blogs with paths `/blog1`, `/blog2` and `/blog3`, we can tell Next that these are our routes. When Next will build our project, it will build these routes out of the box. Pretty neat!

The reason we used `getStaticPaths()` was so that we could eventually use `getStaticProps()`. In this function, we will actually compile our raw MDX using the `serialize` function. Here, we will get the `slug` as a parameter, which we use for getting our raw MDX, which we send to the `serialize` function. 

These are Nextjs specific details, so documentation for these functions would definitely make the picture clearer. But for our blog, the most important thing to understand is this flow -

1. Our component gets the slug as a parameter (eg. `blog1`)
2. We use the slug to retrive the raw MDX (using our `lib/blog.ts` API).
3. Compile the MDX using `serialize`.
4. Send compiled MDX to `<MDXRemote />`.


Now we can finally write our `/posts/[slug].tsx`.

First, let's build our paths and static content. If you are not using Nextjs, then just refer to the component's code in the next snippet.

```ts
// The context we receive here has params that we exported from getStaticPaths
export async function getStaticProps(context: { params: { slug: string } }) {
  const posts = await getAllPosts();

  // Find the post that corresponds to the slug we need
  const currentPost = posts.find((post) => post.metadata.slug === context.params.slug);

  // Nullcheck. Ideally, this will never be null.
  if (!currentPost) {
    return {
      props: {
        source: '',
        metadata: {
          title: '404',
          author: 'Not found',
          slug: context.params.slug,
        },
      },
    };
  }

  // serialize this using MDX's serialize
  const compiledSource = await serialize(currentPost.content);

  // return these as props. The component will consume these now.
  return { props: { source: compiledSource, metadata: currentPost.metadata } };
}

export async function getStaticPaths() {
  // Retrieve all slugs
  const posts = await getAllPosts();

  // construct paths
  const paths = posts.map((post) => ({
    params: {
      slug: post.metadata.slug,
    },
  }));

  // fallback false will ensure that paths will 404
  return {
    paths,
    fallback: false,
  };
}
```

The compiled MDX data is consumed by the component, along with the FrontMatter data in the MDX file.

```tsx
type Props = {
  source: MDXRemoteSerializeResult,
  metadata: FrontMatter
};

// Main component
export default function Page({ source, metadata }: Props) {
  return (
    <div>
      {/* Show the title and author according to the FrontMatter data we added */}
      <h1 className="pt-8 pb-4 text-3xl text-center">
        {metadata.title}
      </h1>
      <p className="italic text-center">
        by
        {' '}
        {metadata.author}
        .
      </p>
      <br />

      {/* Render the content of the page */}
      <p className="container px-64 mx-auto">

        <MDXRemote {...source} />

      </p>
    </div>
  );
}
```

Awesome! We can now render MDX into plain HTML. If we inspect this page in our browser though, we will find that our heading is in an `<h1>` tag and our paragraph is in a `<p>` tag. They are rendered as plain old HTML. Obviously, we would want to customize this and that's what we will do now.

### Customization

In the `<MDXRemote />` component, we can pass a `components` object that instructs the renderer on _how_ to render specific tags. Let's try to customize our `<h1>` and `<p>` tags. These are simple tags that just take `children` as props, but this methodology can be extended to other tags too. [example](https://github.com/SwapnilKumbhar/swapnilk.xyz/tree/main/components/MDX) from my blog. 


